From 12198eb2827652246c286287dc221624f64e09b1 Mon Sep 17 00:00:00 2001
From: Xiongfeng Wang <wangxiongfeng2@huawei.com>
Date: Mon, 31 Jul 2017 14:20:24 +0800
Subject: [PATCH 2/3] arm64: topology: add ACPI PPTT support for arm64

Propagate the topology information of the processor_topology_node tree
to the cpu_topology array. We can get the thread id, core_id or
cluster_id from the cur_level_id member of the leaf
processor_topology_node's parent node in different level.

Signed-off-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
Signed-off-by: John Garry <john.garry@huawei.com>
---
 arch/arm64/kernel/smp.c      | 12 ++++++++++
 arch/arm64/kernel/topology.c | 52 ++++++++++++++++++++++++++++++++++++++++++++
 include/linux/smp.h          |  4 ++++
 3 files changed, 68 insertions(+)

diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c
index 6e0e16a..16cb5d1 100644
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@ -607,6 +607,18 @@ struct acpi_madt_generic_interrupt *acpi_cpu_get_madt_gicc(int cpu)
 
 	return 0;
 }
+
+int __init
+get_cpu_logical_id_for_acpi_processor_id(int acpi_pr_id)
+{
+	int cpu;
+
+	for (cpu = 0; cpu < num_possible_cpus(); cpu++) {
+		if (cpu_madt_gicc[cpu].uid == acpi_pr_id)
+			return cpu;
+	}
+	return -EINVAL;
+}
 #else
 #define acpi_table_parse_madt(...)	do { } while (0)
 #endif
diff --git a/arch/arm64/kernel/topology.c b/arch/arm64/kernel/topology.c
index 0824353..9c8c069 100644
--- a/arch/arm64/kernel/topology.c
+++ b/arch/arm64/kernel/topology.c
@@ -12,6 +12,7 @@
  */
 
 #include <linux/acpi.h>
+#include <linux/acpi_pptt.h>
 #include <linux/cpu.h>
 #include <linux/cpumask.h>
 #include <linux/init.h>
@@ -22,6 +23,7 @@
 #include <linux/sched.h>
 #include <linux/sched/topology.h>
 #include <linux/slab.h>
+#include <linux/smp.h>
 #include <linux/string.h>
 #include <linux/cpufreq.h>
 
@@ -518,6 +520,48 @@ static void __init reset_cpu_topology(void)
 	}
 }
 
+#ifdef CONFIG_ACPI_PPTT
+/*
+ * Propagate the topology information of the processor_topology_node tree to the
+ * cpu_topology array.
+ */
+int __init parse_acpi_topology(void)
+{
+	struct processor_topology_node *pr_node, *tmp_pr_node;
+	u64 mpidr;
+	int cpu;
+
+	mpidr = read_cpuid_mpidr();
+
+	for_each_processor_topology_node(pr_node, tmp_pr_node) {
+		/* Only leaf node represents a single processor or thread */
+		if (pr_node->child)
+			continue;
+
+		cpu = get_cpu_logical_id_for_acpi_processor_id(pr_node->acpi_processor_id);
+		if (cpu < 0)
+			return -EINVAL;
+
+		if (mpidr & MPIDR_MT_BITMASK) {
+			/* Mulit-threads per core, the leaf processor_topology_node is thread */
+			cpu_topology[cpu].thread_id = pr_node->cur_level_id;
+			cpu_topology[cpu].core_id = pr_node->parent->cur_level_id;
+			cpu_topology[cpu].cluster_id = pr_node->package_id;
+		} else {
+			/* Single-thread per core, the leaf processor_topology_node is core */
+			cpu_topology[cpu].core_id = pr_node->cur_level_id;
+			cpu_topology[cpu].cluster_id = pr_node->package_id;
+		}
+	}
+	return 0;
+}
+#else
+int __init parse_acpi_topology(void)
+{
+	return -EINVAL;
+}
+#endif
+
 void __init init_cpu_topology(void)
 {
 	reset_cpu_topology();
@@ -526,6 +570,14 @@ void __init init_cpu_topology(void)
 	 * Discard anything that was parsed if we hit an error so we
 	 * don't use partial information.
 	 */
+	if (acpi_pptt_parsed_successfully()) {
+		if (parse_acpi_topology())
+			reset_cpu_topology();
+		else
+			return;
+	} else
+		return;
+
 	if (of_have_populated_dt() && parse_dt_topology())
 		reset_cpu_topology();
 }
diff --git a/include/linux/smp.h b/include/linux/smp.h
index 68123c1..506890d 100644
--- a/include/linux/smp.h
+++ b/include/linux/smp.h
@@ -127,6 +127,10 @@ static inline int get_boot_cpu_id(void)
 	return __boot_cpu_id;
 }
 
+#ifdef CONFIG_ACPI
+extern int __init get_cpu_logical_id_for_acpi_processor_id(int acpi_pr_id);
+#endif
+
 #else /* !SMP */
 
 static inline void smp_send_stop(void) { }
-- 
1.7.12.4

