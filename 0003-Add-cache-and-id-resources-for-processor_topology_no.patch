From cd9fbf51f850db95b8f199b7b4ae0ee6ac771f22 Mon Sep 17 00:00:00 2001
From: Xiongfeng Wang <wangxiongfeng2@huawei.com>
Date: Mon, 7 Aug 2017 14:05:58 +0800
Subject: [PATCH 3/3] Add cache and id resources for processor_topology_node
 structure

Add fields in processor_topology_node structure to preserve the address
of the processor hierarchy node's cache and id resources.

Signed-off-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
---
 drivers/acpi/pptt.c       | 85 +++++++++++++++++++++++++++++++++++++++++++----
 include/linux/acpi_pptt.h |  9 +++++
 2 files changed, 87 insertions(+), 7 deletions(-)

diff --git a/drivers/acpi/pptt.c b/drivers/acpi/pptt.c
index 95c22b2..5c0dd00 100644
--- a/drivers/acpi/pptt.c
+++ b/drivers/acpi/pptt.c
@@ -70,6 +70,82 @@ void __init init_pr_system_node(void)
 	return NULL;
 }
 
+/* add a acpi_pptt_cache structure into processor_topology_node. */
+static int __init pr_node_add_cache_res(struct processor_topology_node *pr_node,
+		struct acpi_pptt_cache *pptt_cache)
+{
+	unsigned int res_num;
+
+	pr_node->num_pptt_cache++;
+	res_num = pr_node->num_pptt_cache;
+	pr_node->pptt_cache = (struct acpi_pptt_cache **)krealloc(pr_node->pptt_cache,
+			res_num * sizeof(struct acpi_pptt_cache *), GFP_KERNEL);
+
+	if (!pr_node->pptt_cache)
+		return -ENOMEM;
+
+	pr_node->pptt_cache[res_num - 1] = pptt_cache;
+	return 0;
+}
+
+/* add a acpi_pptt_id structure into processor_topology_node. */
+static int __init pr_node_add_id_res(struct processor_topology_node *pr_node,
+		struct acpi_pptt_id *pptt_id)
+{
+	unsigned int res_num;
+
+	pr_node->num_pptt_id++;
+	res_num = pr_node->num_pptt_id;
+	pr_node->pptt_id = (struct acpi_pptt_id **)krealloc(pr_node->pptt_id,
+			res_num * sizeof(struct acpi_pptt_id *), GFP_KERNEL);
+
+	if (!pr_node->pptt_id)
+		return -ENOMEM;
+
+	pr_node->pptt_id[res_num - 1] = pptt_id;
+	return 0;
+}
+
+/*
+ * Populate processor_topology_node structure with information from a processor
+ * hierarchy node.
+ */
+static int __init
+populate_pr_node(struct acpi_pptt_processor *pptt_pr,
+		struct processor_topology_node *pr_node)
+{
+	int i;
+	u32 *priv_res_offset;
+	struct acpi_subtable_header *sub_header;
+
+	pr_node->physical_package = pptt_pr->flags & ACPI_PPTT_PHYSICAL_PACKAGE;
+
+	if (pptt_pr->flags & ACPI_PPTT_ACPI_PROCESSOR_ID_VALID)
+		pr_node->acpi_processor_id = pptt_pr->acpi_processor_id;
+	else
+		pr_node->acpi_processor_id = -1;
+
+	if (!pptt_pr->number_of_priv_resources)
+		return 0;
+
+	priv_res_offset = (u32 *)(pptt_pr + 1);
+	for (i = 0; i < pptt_pr->number_of_priv_resources; i++) {
+		sub_header = ACPI_ADD_PTR(struct acpi_subtable_header,
+				pptt_header, priv_res_offset[i]);
+
+		if (sub_header->type == ACPI_PPTT_TYPE_CACHE) {
+			if (pr_node_add_cache_res(pr_node,
+					(struct acpi_pptt_cache *)sub_header))
+				return -ENOMEM;
+		} else if (sub_header->type == ACPI_PPTT_TYPE_ID) {
+			if (pr_node_add_id_res(pr_node,
+					(struct acpi_pptt_id *)sub_header))
+				return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
 #define MAX_CPU_TOPOLOGY_LEVEL 10
 /*
  * In the process of calculate id for each node, we need a temporary variable
@@ -241,13 +317,8 @@ static int __init insert_pr_node(struct processor_topology_node *pr_node,
 	pr_node->pptt_offset = offset;
 	list_add(&pr_node->list, &pr_node_list);
 
-
-	pr_node->physical_package = pptt_pr->flags & ACPI_PPTT_PHYSICAL_PACKAGE;
-
-	if (pptt_pr->flags & ACPI_PPTT_ACPI_PROCESSOR_ID_VALID)
-		pr_node->acpi_processor_id = pptt_pr->acpi_processor_id;
-	else
-		pr_node->acpi_processor_id = -1;
+	if (populate_pr_node(pptt_pr, pr_node))
+		return -ENOMEM;
 
 	pr_debug("Processor Hierarchy Node: offset=0x%04x flags=0x%x "
 			"parent=0x%04x ACPI Processor ID=%2d\n",
diff --git a/include/linux/acpi_pptt.h b/include/linux/acpi_pptt.h
index 1bf8231..9f2986d 100644
--- a/include/linux/acpi_pptt.h
+++ b/include/linux/acpi_pptt.h
@@ -38,6 +38,10 @@
  *			thread_id, core_id or cluster_id.
  * @depth:		the depth of the node in processor topology tree.
  *
+ * @num_pptt_cache:	size of the following pointer array.
+ * @pptt_cache:		point to a pointer array, each of which point to
+ *			a acpi_pptt_cache structure
+ *
  * @parent:		parent processor topology node
  * @child:		child processor topology node
  * @sibling:		sibling processor topology node
@@ -53,6 +57,11 @@ struct processor_topology_node {
 	unsigned int cur_level_id;
 	unsigned int depth;
 
+	unsigned int num_pptt_cache;
+	struct acpi_pptt_cache **pptt_cache;
+	unsigned int num_pptt_id;
+	struct acpi_pptt_id **pptt_id;
+
 	struct processor_topology_node *parent, *child, *sibling;
 };
 
-- 
1.7.12.4

